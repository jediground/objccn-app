<!DOCTYPE html>
<html>
<head>
    
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />

    
    <title>Android Intents</title>
    <meta name="description" content="" />
    <meta name="HandheldFriendly" content="True" />
    <meta name="MobileOptimized" content="320" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />

    <meta name="google-site-verification" content="m9cRSZABM-v4ZnQ2oia-QgKq1TvTqbZPkFxzYmi31Jc" />
    <meta name="baidu-site-verification" content="q04WZj6EQE" />

    <link rel="shortcut icon" href="../assets/images/favicon.png" />
    
    <link rel="stylesheet" href="../assets/css/ghostion.min.css" />

    
    <link rel="stylesheet" href="../assets/css/ghostion.custom.css" />

    
    <meta name="generator" content="Ghost 0.4" />
<link rel="alternate" type="application/rss+xml" title="objc中国" href="../rss/index.html">
<link rel="canonical" href="../issue-11-2.1.html" />
</head>
<body class="post-template page">
    <div id="at_page_surround">
        <div id="at_body">
            


<div id="at_header">
    <div class="row">
        <div class="medium-4 columns">
            <div class="at_logo_container">
                
                    <a href="../index.html"><img class="at_logo_img" src="../content/images/2014/Mar/logo-1.png" alt="objc中国" />
                    
                    <span class="at_logo_text">objc中国</span></a>
            </div>
        </div>
    </div>
</div>


<div id="at_showcase">
	<div class="at_blog_cover" >
	    <div class="at_showcase_overlay ">
			<div class="row">
				<div class="large-12 large-centered columns">
					<div class="at_block">
						<div class="text-center">
				            
				            <div class="at_block">
				                <article class="post page">
				                    <div class="at_post_header">
				                        <h1 class="at_post_title">Android Intents</h1>
				                    </div>
				                    <div class="at_post_meta">
				                        <span class="at_featured_post"><span class="fa fa-bookmark"></span> <span>Featured</span></span>
				                        <span class="at_post_author"><span class="fa fa-user"></span> sunset</span>
				                        <time class="at_post_time" datetime="2014-04-17"><span class="fa fa-calendar"></span> 17 Apr 2014</time>
				                        <span class="at_post_tags"> </span>
				                    </div>
					                <div class="at_post_share">
					                    <h6 class="at_post_share_title">分享文章</h6>
					                    <a class="at_post_share_icon" href="http://twitter.com/share?text=%23objc%E4%B8%AD%E5%9B%BD%20Android%20Intents&url=http://objccn.io/issue-11-2/"
					                        onclick="window.open(this.href, 'twitter-share', 'width=550,height=235');return false;">
					                        <span class="fa fa-twitter-square"></span>
					                    </a>
					                    <a class="at_post_share_icon" href="https://www.facebook.com/sharer/sharer.php?u=http://objccn.io/issue-11-2/"
					                        onclick="window.open(this.href, 'facebook-share','width=580,height=296');return false;">
					                        <span class="fa fa-facebook-square"></span>
					                    </a>
					                    <a class="at_post_share_icon" href="http://service.weibo.com/share/share.php?url=http://objccn.io/issue-11-2/&appkey=&title=%23objc%E4%B8%AD%E5%9B%BD%23%20Android%20Intents&pic=&ralateUid=&language=zh_cn"
					                        onclick="window.open(this.href, 'twitter-share', 'width=550,height=235');return false;">
					                        <span class="fa fa-weibo"></span>
					                    </a>
					                </div>
				                </article>
				            </div>
				            
						</div>
					</div>
				</div>
			</div>
	    </div>
	</div>
</div>


<div id="at_mainbody" class="at_post" role="main">
    <div class="row">
        <div class="large-12 columns">
            
            <div class="at_block">
                <article class="post page">
                    <div class="at_post_content">
                        <h2 id="">简介</h2>

<p>说起 Android，最大的特点莫过于运行其平台上的应用可以很容易的启动别的应用以及互相之间分享数据。回首 iOS 1.0 时代，应用之间是完全隔离的，无法进行通信（至少非 Apple 应用之间是这样的），甚至到了 iOS SDK 面世之时，这种状况也没有改变。</p>

<p>iOS 6 之前的系统，若要在编写邮件过程中直接加入照片或视频是件很麻烦的事。iOS 6 发布以后，这项功能才得到根本性的改善。但是在 Android 的世界里，自发布的第一天，这种功能就是天生携带的。</p>

<p>类似的系统平台层面的差异还有许多。比如有这样一个场景：拍一张照片，然后用某个图片处理 app 里编辑一下，接着将照片分享到 Instagram。</p>

<p><em>注意：这里只是列举个别细节。</em></p>

<p>iOS的做法是：</p>

<ol>
<li>打开系统拍照应用拍张照片。  </li>
<li>回到主界面，找到<em>图片编辑</em>应用，启动应用，选择已存在照片，从系统相册里选取照片，然后编辑。  </li>
<li>如果<em>图片编辑</em>应用恰好支持直接分享<strong>且</strong> Instagram 又在分享列表中，就此完成任务。  </li>
<li>如果第 3 点条件不满足，那就得先把编辑好的照片保存到系统相册。  </li>
<li>再一次回到主界面，找到 <em>Instagram</em> 然后打开它...  </li>
<li>导入之前编辑保存的照片，然后分享给 Instagram 上的潮友们。;)</li>
</ol>

<p>至于 Android，就简单得多了：</p>

<ol>
<li>打开拍照应用，拍张照片。  </li>
<li>向右滑查看“相册”，然后点击分享按钮。选择想要使用的<em>图片编辑</em>应用，然后直接编辑。  </li>
<li>如果<em>图片编辑</em>应用支持直接分享（我还从来没见过哪个图片处理应用不支持直接分享的），点击分享然后选择 Instagram。假如这个应用不支持分享，直接卸载算了，换个靠谱的应用来处理，或者干脆用系统集成的图片编辑器。KitKat 之后的系统内建编辑器已经相当酷炫。</li>
</ol>

<p>需要说明的是，对于那些提供分享功能的 iOS 应用来说，其处理流程和 Android 基本是一致的。根本性的差别是，如果应用本身不支持分享那就断绝了分享给其他应用的道路。与 Facebook 和 Twitter 一样，Instagram 这类热门应用还好，但是除此之外还有大量的应用，基本上没什么应用会集成针对它们的分享服务。</p>

<p>比如说你想把 Instagram 里的某张照片分享到 Path 上面（我知道，Path 比较小众，但是...）。如果是 Android 系统，直接从 <em>chooser dialog (选择对话框)</em> 中选择 Path 即可。就是这么简单。</p>

<p>还是说回正题，<em>Intents</em>。</p>

<h2 id="androidintent">什么是 Android Intent？</h2>

<p>在英语词典里 Intent 的定义是：</p>

<pre><code>noun （名词）
intention or purpose （意图、目的）
</code></pre>

<p>来自 Android <a href="http://developer.android.com/guide/components/intents-filters.html">官方文档</a>的说明是，<code>Intent</code> 对象<em>主要解决 Androi d应用各项组件之间的通讯</em>。事实上，Intent 就是对将要执行的操作的一种抽象描述。</p>

<p>看起来很简单，实际上 Intent 的意义远不止于此。在 Android 世界中，Intent 几乎随处可见，无论你开发的 app 多么简单，也离不开 Intent；小到一个 Hello World 应用也是要使用 Intent 的。因为 Intent 最基础最常见的用法就是启动 <code>Activity</code>。[^1]</p>

<h2 id="activitiesfragments">如何理解 Activities 和 Fragments</h2>

<p>在iOS中，与 <code>Activity</code> 相比较，最相似的东西就是 <code>UIViewController</code> 了。切莫在 Android 中寻找 <code>ApplicationDelegate</code> 的等价物，因为没有。也许只有 <code>Application</code> 类稍微贴近于 <code>ApplicationDelegate</code> ，但是从架构上看，它们有着本质的区别。</p>

<p>由于厂商把手机屏幕越做越大，一个全新的概念 <code>Fragments</code>[^2]（碎片）随之而生。最典型的例子就是新闻阅读类应用。在小屏幕的手机上，一般用户只能先看到文章列表。选中一篇文章后，才会全屏显示文章内容。</p>

<p>没有 <code>Fragments</code> 的时候，开发者需要创建两个 activities（一个用于展示文章列表，另一个用于全屏展示文章详情），然后在两者来回切换。</p>

<p>在出现大屏幕的平板之前，这么都做没什么问题。因为原则上，同一时间只有<strong>一个</strong> activity 对用户可见，但自从 Android 团队引入了 <code>Fragments</code>，一个宿主 <code>Activity</code> 就可以同时展示多个 <code>Fragments</code> 了。</p>

<p>现在，完全可以用一个 <code>Activity</code> 嵌入<strong>两个</strong> <code>Fragments</code> 的方式来替代先前使用两个不同 <code>Activities</code> 的做法。一个 <code>Fragment</code> 用来展示文章列表，另一个用来展示详情。对于小屏幕的手机，可以用两个 <code>Fragments</code> 交替显示文章列表和详情。如果是平板设备，宿主 Activity 会同时显示两个 Fragments 的内容。类似的东西可以想像一下 iPad 中的邮件应用，在同一屏中，左边是收件箱，右边是邮件列表。</p>

<h3 id="activities">启动 Activities</h3>

<p>Intents 最常见的用法就是用来启动 activities（以及在 activities 之间传递数据）。<code>Intent</code> 通过定义两个 activities 之间将要执行的动作从而将它们粘合起来。</p>

<p>然而启动一个 <code>Activity</code> 并不简单。Android 中有一个叫做 <code>ActivityManager</code> (活动管理器)的系统组建负责创建、销毁和管理 activities。这里不去过多探讨 <code>ActivityManager</code> 的细节，但是需要指出的是它承担全程监视已启动的 activities 以及在系统内发送广播通知的职责，比如说，启动过程结束这件事就是由 <code>ActivityManager</code> 来向安卓系统的其他部分发放通知的。</p>

<p><code>ActivityManager</code> 是安卓系统的一个极重要的部分，同时它依靠 <code>Intents</code> 来完成大部分工作。</p>

<p>那么 Android 系统到底是如何利用 <code>Intent</code> 来启动 <code>Activity</code> 的呢？</p>

<p>如果你仔细挖掘一下 <code>Activity</code> 的类结构就会发现：它继承自 <code>Context</code>，里面恰好有个抽象方法 <code>startActivity()</code>，其定义如下：</p>

<pre><code>public abstract void startActivity(Intent intent, Bundle options);
</code></pre>

<p><code>Activity</code> 实现了这个抽象方法。也就是说只要传递了正确的 <code>Intent</code>，可以对任意一个 <code>Activity</code> 执行启动操作。</p>

<p>比如说我们要启动一个名为 <code>ImageActivity</code> 的 <code>Activity</code>。</p>

<p>其中 <code>Intent</code> 的构造方法是这样的：</p>

<pre><code>public Intent(Context packageContext, Class&lt;?&gt; cls)
</code></pre>

<p>需要传递参数 <code>Context</code>（注意，可以认为每一个 <code>Activity</code> 都是一个有效的 <code>Context</code>）和 <code>Class</code> 类。</p>

<p>接下来：</p>

<pre><code>Intent i = new Intent(this, ImageActivity.class);
startActivity(i);
</code></pre>

<p>这之后会触发一系列调用，如无意外，最终会成功启动一个新的 <code>Activity</code>，当前的 <code>Activity</code> 会进入 paused（暂停）或者 stopped（停止）状态。</p>

<p>Intents 还可以用来在 Activities 之间传递数据，比如我们将信息放入 <em>Extras</em> 来传递：</p>

<pre><code>Intent i = new Intent(this, ImageActivity.class);
i.putExtra("A_BOOLEAN_EXTRA", true); //boolean extra
i.putExtra("AN_INTEGER_EXTRA", 3); //integer extra
i.putExtra("A_STRING_EXTRA", "three"); //integer extra
startActivity(i);
</code></pre>

<p><em>extras</em> 存储在 Android 的 <code>Bundle</code>[^3]中，<code>Bundle</code> 在这里可以被看做是一个可序列化的容器。</p>

<p>这样 <code>ImageActivity</code> 就可以通过 <code>Intent</code> 来接收信息，可以通过如下方式将信息取出：</p>

<pre><code> int value = getIntent().getIntExtra("AN_INTEGER_EXTRA", 0); //名称，默认值
</code></pre>

<p>上面就是如何在 Activities 之间传简单值。当然也可以传序列化对象。</p>

<p>假如一个对象已实现序列化接口 <code>Serializable</code>。接下来可以这么做：</p>

<pre><code>YourComplexObject obj = new YourComplexObject();
Intent i = new Intent(this, ImageActivity.class);
i.putSerializable("SOME_FANCY_NAME", obj); //使用接收序列化对象的方法
startActivity(i);
</code></pre>

<p>其它的 <code>Activity</code> 也要使用相应的序列化取值方法获取值：</p>

<pre><code>YourComplexObject obj = (YourComplexObject) getIntent().getSerializableExtra("SOME_FANCY_NAME");
</code></pre>

<p>特别说明，<em>从 Intent 取值的时候请记得判空</em>：</p>

<pre><code>if (getIntent() != null ) {
         //确认Intent非空后，可以进行诸如从extras取值什么的…
}
</code></pre>

<p>在 Java 的世界中对空指针很敏感。所以要多加防范。;)</p>

<p>使用 <code>startActivity()</code> 启动了新的 activity 后，当前的 activity 会依次进入 paused 和 stopped 状态，然后进入任务堆栈，当用户点击 <em>back</em> 按钮后，activity 会再次恢复激活。正常情况下，这一系列流程没什么问题，不过还是可以通过向 Intent 传递一些 <em>Flags（标识）</em>来通知 <code>ActivityManager</code> 去改变既定行为。</p>

<p>由于这是一个很大很复杂的话题，此处就不做过多的展开了。可以参见文档 <a href="http://developer.android.com/guide/components/tasks-and-back-stack.html">任务和返回栈的官方文档</a>来了解 <em>Intent Flags</em>。</p>

<p>下面看看 <code>Intents</code> 除了启动 Activity 还能做些什么。</p>

<p><code>Intents</code> 还有两个重要职责：</p>

<ul>
<li>启动 <code>Service</code>[^4]（或向其发送指令）。</li>
<li>发<code>Broadcast</code>（广播）。</li>
</ul>

<h3 id="">启动服务</h3>

<p>由于 <code>Activities</code> 不能在后台运行（因为在后台它们会进入 paused 态，stopped 态，甚至是 destroyed 销毁状态），如果想要执行的后台进程不需要 UI，可以使用 <code>Service</code> （服务）作为替代方案。Services 本身也是个很大的话题，简单的说它就是：没有界面或 UI 不可见的运行在后台的任务。</p>

<p>由于 Services 如无特殊处理是运行在UI线程上的，所以当系统内存紧张时，Services 极有可能被销毁。也就是说，如果 Services 所要执行的是一个耗时操作，那么就应该为 Services 开辟单独的线程，一般都是通过 <a href="http://developer.android.com/reference/android/os/AsyncTask.html">AsyncTask</a> 来创建。比如一个 <code>Service</code> 要执行媒体播放任务，可以通过申请 <em>Foreground（前台）</em>服务状态来<strong>强制</strong>在通知栏中一直显示一个通知，给用户展示当前服务在做些什么。应用也可以取消前台状态（通知栏上的相应状态通知也会随之消失），但是这么做的话 <code>Service</code> 就失去了较高的状态优先级。</p>

<p><code>Services</code> 机制是非常强大的，它也是 Android “多任务”处理的基础，而在早前，它被认为是影响电池用量的关键因素。其实早在 iOS 还未支持多任务的时代，Android 已经在自如的操纵多任务处理了。使用正确的话，<code>Services</code> 是平台必不可少的重要组成部分。</p>

<p>在以前，有一个很争议的问题，就是 <code>Service</code> 可以在<strong>没有</strong>任何通知的情况下转入前台运行。也就是说在用户不知情的情况下，后台可能会启动大量的服务来执行各种各样的任务。自 Android 4.0 (Ice Cream Sandwich) 之后，Google终于修复了这个“隐形”通知的问题，让无法杀掉进程且在后台静默运行的应用程序在通知栏上<strong>“显形”</strong>，用户甚至可以从通知栏中切换到应用内（然后杀掉应用）。虽然现在 Android 设备的续航还远不及 iOS 产品，但是至少后台静默 <code>Services</code> 已经不再是耗电的主因了。;)</p>

<p><code>Intents</code> 和 <code>Services</code> 是怎么协作的呢？</p>

<p>首先需要一个 <code>Intent</code> 来启动 Service。而 <code>Service</code> 启动后，只要其处于非 stopped 状态，就可以持续地向它发送指令，直到它被停止（在这种情况下它将会重新启动）。</p>

<p>在某个 <code>Activity</code> 中启动服务：</p>

<pre><code>Intent i = new Intent(this, YourService.class);
i.setAction("SOME_COMMAND");
startService(i);
</code></pre>

<p>接下来程序执行情况取决于当下是否第一次启动服务。如果是，那么服务就会自然启动（首先执行构造方法和 <code>onCreate()</code> 方法）。如果该服务已经启动过，将会直接调用 <code>onStartCommand()</code> 方法。</p>

<p>方法的具体定义：<code>public int onStartCommand(Intent intent, int flags, int startId);</code></p>

<p>此处重点关注 <code>Intent</code>。由于 <code>flags</code> 和 <code>startId</code> 与我们要探讨的话题相关性不大，这里直接忽略不赘述。</p>

<p>之前我们通过 <code>setAction("SOME_COMMAND")</code> 设置了一个 <code>Action</code>。<code>Service</code> 可以通过 <code>onStartCommand()</code> 来获取该 action。拿上面的例子来说，可以这么做：</p>

<pre><code>@Override
public int onStartCommand(Intent intent, int flags, int startId) {
    String action = intent.getAction();
    if (action.equals("SOME_COMMAND")) {
        // SOME_COMMAND 具体事件内容)
    }
    return START_NOT_STICKY; // 如果服务已被杀掉，不要重新启动服务
}
</code></pre>

<p>如果对 <code>START_NOT_STICKY</code> 感兴趣，请参见此<a href="http://developer.android.com/reference/android/app/Service.html">安卓文档</a>有很详尽的描述。</p>

<p><strong>简而言之</strong>：如果 <code>Service</code> 已经被杀掉，不需要重启。与之相反的是 <code>START_STICKY</code>，这个表示应当执行重启。</p>

<p>从上面的代码段可知，能够从 <code>Intent</code> 中获取 <code>Action</code>。这就是比较常见的与 <code>Services</code> 的通讯方式。</p>

<p>假设我们要开发一个应用，将 Youtube 的视频以流式输送给 Chromecast (<em>虽然现有的Youtube应用已经具备这个功能了，但既然是 Android，我们还是希望自己做一个</em>)。</p>

<p>通过一个 <code>Service</code>来实现流式播放，这样当用户在播放视频的过程中切换到其它应用的时候，播放也不会停止。定义几种 actions：</p>

<pre><code>ACTION_PLAY, ACTION_PAUSE, ACTION_SKIP.
</code></pre>

<p>在 <code>onStartCommand()</code> 内，可以通过 <code>switch</code> 或者 <code>if</code> 条件判断，然后针对每一种情况做相应的处理。</p>

<p>理论上，服务可以随意命名，但通常情况下会使用常量（稍后会举例）来命名，良好的命名可以避免和其它应用的服务名产生冲突，比如说使用完整的包名 '<code>com.yourapp.somepackage.yourservice.SOME_ACTION_NAME</code>'。如果将服务名设为私有，那么服务只能和自己的应用通讯，否则要是想和其它应用通讯则需要将服务名公开。</p>

<h3 id="">发送和接收广播</h3>

<p>Android 平台的强大特性之一就是：任何一个应用都可以广播一个 <code>Intent</code>，同时，任意应用可以通过定义一个 <code>BroadcastReceiver</code>（广播接收者）来接收广播。事实上，Android 本身就是采用这个机制来向应用和系统来发送事件通知的。比如说，网络突然变成不可用状态，Android 组件就会广播一个 <code>Intent</code>。如果对此感兴趣，可以创建一个 <code>BroadcastReceiver</code>，设置相应的<strong>filter（过滤器）</strong>来截获广播并作出适当的处理。</p>

<p>可以将这个过程解为订阅一个全局的频道，并且根据自己的喜好配置过滤条件，接下来会接收符合条件的广播信息。另外，若只是想要自己的应用接收广播，需要定义成私有。</p>

<p>继续前面的 Youtube 播放服务的例子，如果在播放的过程中出现了问题，服务可以发送一个 <code>Intent</code> <em>广播</em>来发布信息，比如“播放遇到问题，将要停止播放”。</p>

<p>应用可以注册一个 <code>BroadcastReceiver</code> 来监听 <code>Service</code>，以便对收到的广播做出处理。</p>

<p>下面看一些样例代码。</p>

<p>基于上面的例子，你可能会定义一个 <code>Activity</code> 用来展示和播放有关的信息和操作，比如当前的播放进度和媒体控制按钮（播放，暂停，停止等等）。你可能会非常关注当前服务的状态；一旦有错误发生，你需要及时知晓（可以向用户展示错误提示信息等等）。</p>

<p>在 activity（或者一个独立的 .java 文件）中可以创建一个广播接收器：</p>

<pre><code>private final class ServiceReceiver extends BroadcastReceiver {
    public IntentFilter intentFilter;
    public ServiceReceiver() {
        super();
        intentFilter = new IntentFilter();
        intentFilter.addAction("ACTION_PLAY");
        intentFilter.addAction("ACTION_STOP");
        intentFilter.addAction("ACTION_ERROR");
    }
    @Override
    public void onReceive(final Context context, final Intent intent) {
        if (intent.getAction().equals("ACTION_ERROR")) {
           // 由于有错误发生，播放停止
        } else if (intent.getAction().equals("ACTION_PLAY")){
           // 播放视频
        }
        // 等等…
    }
 }
</code></pre>

<p>receiver 的实现大概如此。这里需要注意下我们向 <code>IntentFilter</code> 中添加的 <code>Actions</code>。它们分别为 <code>ACTION_PLAY</code>（播放）， <code>ACTION_STOP</code>（停止）， 和 <code>ACTION_ERROR</code>（错误）。</p>

<p>由于我们使用的是 Java，列举一下 Android 的习惯用法：</p>

<p><code>private ServiceReceiver mServiceReceiver;</code> 可以用此法将其定义为 Activity 的<em>成员变量</em>。然后在 <code>onCreate()</code> 方法中对其进行实例化，比如：<code>mServiceReceiver = new ServiceReciver();</code>。</p>

<p>当然，单单创建这样的一个对象是不够的。我们需要在某处进行注册。第一反应，你可能会认为可以在 <code>Activity</code> 的 <code>onStart()</code> 方法内注册。当 <code>onStart()</code> 执行的时候，意味着用户可以看到这个 <code>Activity</code> 了。</p>

<p>注册方法详情如下（定义在 <code>Context</code> 中）：</p>

<pre><code>public abstract Intent registerReceiver(BroadcastReceiver receiver, IntentFilter filter);
</code></pre>

<p><em>由于 <code>Activities</code> 和 <code>Services</code> 都是 <code>Contexts</code>，所以它们本身都实现了这个方法。这表示它们都可以注册一个或多个 <code>BroadcastReceivers</code>。</em></p>

<p>此方法需要参数 <code>BroadcastReceiver</code> 和 <code>IntentFilter</code>。之前已经创建好，可直接传参：</p>

<pre><code>@Override
public void onStart() {
    onStart();
      registerReceiver(mServiceReceiver, mServiceReceiver.intentFilter);
}
</code></pre>

<p>请养成良好的 Java / Android 开发习惯，当 <code>Activity</code> 停止的时候，请注销相应的注册信息：</p>

<pre><code>@Override
public void onStop() {
    super.onStop();
    unregisterReceiver(mServiceReceiver);
}
</code></pre>

<p>这种处理本身没什么问题，但是要提醒大家，一旦用户离开了当前应用，将不会再收到广播。这是由于 <code>Activity</code>即将停止，此处在 <code>onStop()</code> 这里注销了广播接收。所以当你设计 <code>BroadcastReceivers</code> 的时候，需要考虑清楚，这种处理方式是否适用。毕竟还有其它不依赖于 <code>Activity</code> 的实现方式可供选择。</p>

<p>每当 <code>Service</code> 侦测到错误发生，它都会发起一个广播，这样 <code>BroadcastReceiver</code> 可以在 <code>onReceive()</code> 方法中接收广播信息。</p>

<p>广播接收处理也是 Android 中非常重要非常强大非常核心的机制。</p>

<p>读到这里，爱思考的读者们可能会问这些广播到底可以 <em>全局</em>到什么程度？如何将广播设置为私有以及如何限制它们只和其所属应用通讯？</p>

<p>事实上 Intents 有两类：<em>显式的 (explicit) *和</em>隐式的 (implicit)*。</p>

<p>所谓显式 Intent 就是明确指出了目标组件名称的 Intent，由于不清楚其它应用的组件名称，显式 Intent 一般用于启动自己应用内部的组件。隐式 Intent 则表示不清楚目标组件的名称，通过给出一些对想要执行的动作的描述来寻找与之匹配的组件（通过定义过滤器来罗列一些条件用于匹配组件），隐式 Intent 常用于启动其它应用的组件。</p>

<p>鉴于之前给出的例子中使用的就是<em>显式 Intents</em>，这里将重点讨论一下<em>隐式 Intents</em>。</p>

<p>我们通过一个简单的例子来看看<em>隐式 Intents</em>的强大之处。定义过滤器 (filter) 有两种方式。第一种与 iOS 的自定义 URI 机制很类似，比如：yourapp://some.example.com。</p>

<p>如果你的设计是想 Android 和 iOS 都通用，那么别无他法只能使用 URI 策略。如果只是针对 Android 平台的话，建议尽量使用标准 URL 的方式（比如 <a href='http://your.domain.com/yourparams）。之所以这么说是因为这与如何看待自定义'>http://your.domain.com/yourparams）。之所以这么说是因为这与如何看待自定义</a> URI 方案的利与弊有关，对这个问题不做具体的展开了，总而言之（下文引自 stackoverflow）：</p>

<blockquote>
  <p>为了避免不同实体之间的命名冲突，web 标准要求应严格要控制 URI 的命名。而使用自定义 URI 方案与其 web 标准相违背。一旦将自定义 URI 方案部署到互联网上，等于直接将方案名称投入到整个互联网的命名空间中去（会又很大的命名冲突可能性），所以应严格遵守相应的标准。</p>
</blockquote>

<p>来源：<a href="http://stackoverflow.com/a/2449500/2684">StackOverflow</a></p>

<p>上述问题暂且放一边，下面看两个例子，一个是用标准 URL 来实现之前 YouTube app，另一个是在我们自己的 app 中采用自定义 URI方案。</p>

<p>因为每个Android都有配置文件<code>AndroidManifest.xml</code>，可以在其中定义<code>Activities</code>，<code>Services</code>，<code>BroadcastReceivers</code>，versions（版本信息），Intent filter等描述信息，所以实现起来比较简单。<a href="http://developer.android.com/guide/topics/manifest/manifest-intro.html">详情见文档</a>。</p>

<p>Intent 过滤器的本质是系统依照过滤条件检索当前已安装的所有应用，看看有哪些应用可以处理指定的 URI。</p>

<p>如果某个 app 刚好匹配且是唯一能够匹配的 app，就会自动打开这个 app。否则的话，可以看到类似这样的一个选择对话框：</p>

<p><img src="http://img.objccn.io/issue-11/android-dialog-choser.jpg" alt="image" /></p>

<p>为什么 Youtube 的官方应用会出现在清单上呢？</p>

<p>我只是在 Facebook 的应用里点了一个 Youtube 的链接而已。为什么 Android 会知道我点的是 Youtube 的链接？<em>这其中有什么玄机</em>？</p>

<p>假设我们打开 Youtbube 应用的 <code>AndroidManifest.xml</code>，我们应该能看到类似如下的配置：</p>

<pre><code>1 &lt;activity android:name=".YouTubeActivity"&gt;
2     &lt;intent-filter&gt;
3        &lt;action android:name="android.intent.action.VIEW" /&gt;
4       &lt;category android:name="android.intent.category.DEFAULT" /&gt;
5         &lt;category android:name="android.intent.category.BROWSABLE" /&gt;
6       &lt;data
7        android:scheme="http"
8        android:host="www.youtube.com"
9        android:pathPrefix="/" /&gt;
10   &lt;/intent-filter&gt;
11 &lt;/activity&gt;
</code></pre>

<p>接下来我们会逐行解释一下这段XML信息。</p>

<p>第 1 行是声明 activity（Android 中的每个 <code>activity</code> 都必须在配置文件中声明，而过滤器则不是必须的）。</p>

<p>第 2 行声明了 action。此处的 <code>VIEW</code> 是最常用的action，它表示会向用户展示数据。因为还存在一些受保护的只能用于系统级传输的 action。</p>

<p>第 4－5 行声明了类别 (categories)。隐式 Intents 要求至少有一个 action 和一个 category。categories 里主要定义 Intent 所要执行的 Action 的更多细节。在解析 Intent 的时候，只有满足 categories 中全部描述条件的 activities 才会被使用。Android 把所有传给 <code>startActivity()</code> 的隐式 Intent 当作它们包含至少一个 category <code>android.intent.category.DEFAULT</code> (CATEGORY_DEFAULT 常量)，想要接收隐式 Intent 的 <code>Activity</code> 必须在它们的 Intent Filter 中配置 <code>android.intent.category.DEFAULT</code>。</p>

<p><code>android.intent.category.BROWSABLE</code> 是另一个敏感配置：</p>

<blockquote>
  <p>能通过浏览器安全调用的 Activity 必须支持这个 category。比如，用户从正在浏览的网页或者文本中点击了一个 e-mail 链接，接下来生成执行这个 link 的 Intent 会含有 BROWSABLE categroy 描述，所以只有支持这个 category 的 activities 才会有可能被匹配到。一旦承诺支持这个 category，在被 Intent 匹配调用后，必须保证没有恶意的行为或内容（至少是在用户不知情的情况下不可以有）。</p>
</blockquote>

<p>来源：<a href="http://developer.android.com/reference/android/content/Intent.html#CATEGORY_BROWSEABLE">Android Documentation（官方文档）</a></p>

<p>这个点很关键，Android 通过它构建了一种机制，允许应用去响应任何的链接。利用这个机制你完全可以构建自己的浏览器去处理任何 URL 的请求，如果用户喜欢的话完全可以将你的浏览器设置成默认浏览器。</p>

<p>第 6-9 行声明了所要操作的数据<em>类型</em>。在本例中，我们使用 scheme（方案／策略）和 host（主机）来进行过滤，所以任何以 <a href='http://www.youtube.com/'>http://www.youtube.com/</a> 开头的链接均可处理，哪怕是在 web 浏览器里点击链接。</p>

<p>在 Youtube 应用内的 <code>AndroidManifest.xml</code> 里配置以上信息后，每当 <em>Intent 解析</em>的时候，Android 都会在系统已安装的应用中根据 <code>&lt;intent-filter&gt;</code> 内定义的信息来过滤和匹配 Intent（或者像我们的例子一样，从通过代码注册的 <code>BroadcastReceivers</code> 中寻找）。</p>

<p>Android <code>PackageManager</code>[^5] 会根据 <code>Intent</code> 信息（action，type 和 category）来寻找符合条件的组件来处理 Intent。如果找到唯一合适的组件，会自动调用，否则会像上面例子里那样弹出一个选择对话框，这样用户可以自行选择应用（或者根据默认设置中指定的应用）来处理 Intent 动作。</p>

<p>这个方案适用于大多数的应用，但是如果想要采取和 iOS 一样的 link 就只能使用自定义 URI。不过在 Android 中，两种方案是都支持的，而且还可以对同样的 activity 增加多种过滤条件。还是以 YoutubeActivity 为例，我们假定一个 Youtube URI 方案配置上去：</p>

<pre><code>1 &lt;activity android:name=".YouTubeActivity"&gt;
2     &lt;intent-filter&gt;
3        &lt;action android:name="android.intent.action.VIEW" /&gt;
4       &lt;category android:name="android.intent.category.DEFAULT" /&gt;
5         &lt;category android:name="android.intent.category.BROWSABLE" /&gt;
6       &lt;data
7        android:scheme="http"
8        android:host="www.youtube.com"
9        android:pathPrefix="/" /&gt;
10      &lt;data android:scheme="youtube" android:host="path" /&gt;
11   &lt;/intent-filter&gt;
12 &lt;/activity&gt;
</code></pre>

<p>这个 filter 和先前配置的基本一致，除了在第 10 行增配了自定义的 URI 方案。</p>

<p>这样的话，应用可以支持打开诸如：<code>youtube://path.to.video</code> 的链接，也可以打开普通的 HTTP 链接。总之，你想给 <code>Activity</code> 中配置多少 filters 和 types 都可以。</p>

<h4 id="uri">使用自定义 URI 方案到底有什么负面影响？</h4>

<p>自定义 URI 方案的问题是它不符合 W3C 针对 URIs 制定的各项标准。当然这个问题也并不绝对，如果只是在应用包内使用自定义 URI 是 OK 的。但像前文所说，若公开自定义 URI 则会存在命名冲突的风险。假如定义一个 URI 为 <code>myapp://</code>，谁也不能保证别的应用不会定义同样的东西，这就会有问题。反过来说，使用域名就不存在这种冲突的隐患。拿我们之前构建了自己的 Youtube 播放 app 来说，Android 会提供选择是启用自己的 Youtube 播放器还是使用官方 app。</p>

<p>同时，浏览器可能无法解析某些自定义URL，比如 <code>yourapp://some.data</code>，极有可能报 404。这就是<em>违背</em>规则和不遵守标准的风险。</p>

<h3 id="">数据分享</h3>

<p>可以通过 <code>Intent</code> 向其他应用<em>分享</em>信息，比如说向社交网网站<em>分享</em>个帖子，向图片编辑 app 传递一张图片，发邮件，发短息，或者通过即时通讯应用传些资源什么的等等都是再分享数据。目前为止，我们介绍了怎么创建 intent filters，还有如何将应用注册成广播接收者以便在收到可响应的通知时做出相应的处理。在本文的最后一部分，将要探讨一下如何<em>分享</em>内容。再一次：<em>所谓 Intent 就是对将要执行的动作的一种抽象描述</em>。</p>

<h4 id="">分享到社交网站</h4>

<p>在下面的例子中，我们会分享一个文本信息并且让用户做出最终的选择：</p>

<pre><code>1  Intent shareIntent = new Intent(Intent.ACTION_SEND);
2  shareIntent.setType("text/plain");
3  shareIntent.putExtra(Intent.EXTRA_TEXT, "Super Awesome Text!");
4  startActivity(Intent.createChooser(shareIntent, "Share this text using…"));
</code></pre>

<p>第 1 行使用构造方法 <code>public Intent(String action)</code> 根据指定 action 创建了一个 <code>Intent</code>；</p>

<p><code>ACTION_SEND</code> 表示会向别的应用<em>发送数据</em>。在本例中，要传递的信息是 “Super Awesome Text!”。但是目前为止还不知道要传给谁。最终，这将由用户决定。</p>

<p>第 2 行设置 MIME 数据的类型为 <code>text/plain</code>。</p>

<p>第 3 行将要传递的数据通过 <code>exstra</code> 放到 Intent 中去。</p>

<p>第 4 行会触发本例的用户选择功能。其中 <code>Intent.createChooser</code> 是将 Intent 重新封装，将其 action 指定为 <code>ACTION_CHOOSER</code>。</p>

<p>这里面没什么特别复杂的东西。这个 action 就是用来弹出选择界面的，也就是说让用户自己选择处理方式。某些场景下，你可能会设计呈现更加具体的选择（比如用户正在发送 email，可以直接给用户提供统默认的邮件客户端），但是就本例而言，任何能够处理我们要分享的文本的应用都会被纳入选择清单。</p>

<p>具体的运行效果（选择列表太长了，得滚动着来看）如下：</p>

<p><img src="http://img.objccn.io/issue-11/android-chooser.gif" alt="image" /></p>

<p>而后我选择了用 Google Translate 来处理文本，结果如下：</p>

<p><img src="http://img.objccn.io/issue-11/android-translate.jpg" alt="image" /></p>

<p>Google Translate 将刚刚的文本翻译成了意大利文。</p>

<h2 id="">再给出一个例子</h2>

<p>总结之前，再看个例子。这次会展示如何分享和接收一张图片。也就是说，当用户分享图片时，让我们的 app 出现在用户的分享选择列表中。</p>

<p>在 <code>AndroidManifest</code> 做如下配置：</p>

<pre><code>1    &lt;activity android:name="ImageActivity"&gt;
2        &lt;intent-filter&gt;
3            &lt;action android:name="android.intent.action.SEND"/&gt;
4            &lt;category android:name="android.intent.category.DEFAULT"/&gt;
5            &lt;data android:mimeType="image/*"/&gt;
6        &lt;/intent-filter&gt;
7    &lt;/activity&gt;
</code></pre>

<p>注意，至少要配置一个 action 和一个 category。</p>

<p>第 3 行将 action 配置为 <code>SEND</code>，表示可以配置 <code>SEND</code> 类型的 actions。</p>

<p>第 4 行声明 category 为 <code>DEFAULT</code>。当使用 <code>startActivity()</code> 的时候，会默认添加 category。</p>

<p>第 5 行很重要，是将 MIME 类型设置为<em>任何类型的图片</em>。</p>

<p>接下来，在 <code>ImageActivity</code> 中对Intent的处理如下：</p>

<pre><code>1    @Override
2    protected void onCreate(Bundle savedInstanceState) {
3        super.onCreate(savedInstanceState);
4        setContentView(R.layout.main);
5        
6        // 处理intent（如果有intent）
7        Intent intent = getIntent();
8        if ( intent != null ) {
9            if (intent.getType().indexOf("image/") != -1) {
10                 Uri data = intent.getData();
11                 //  处理image…
12            } 
13        }
14    }
</code></pre>

<p>有关的处理代码在第 9 行，在检查 Intent 中是否包含图片数据。</p>

<p>接下来来看看<em>分享</em>图片的处理代码：</p>

<pre><code>1    Uri imageUri = Uri.parse("/path/to/image.png");
2    Intent intent = new Intent(Intent.ACTION_SEND);
3    intent.setType("image/png");    
4    intent.putExtra(Intent.EXTRA_STREAM, imageUri);
5    startActivity(Intent.createChooser(intent , "Share"));
</code></pre>

<p>关键代码在第 3 行，定义了 MIME 类型（只有 <code>IntentFilters</code> 匹配到的应用才会出现在选择列表中），第 4 行是将要分享的数据放入 Intent 中。</p>

<p>最后，第 5 行创建了之前看到过的<em>选择</em>对话框，其中只有能够处理 <code>image/png</code> 的应用才会出现在选择对话框的列表中。</p>

<h2 id="">总结</h2>

<p>我们从大体上介绍了什么 Intent，它能做些什么，以及如何在 Android 中分享信息，但是还有很多内容本文没有涵盖。Intent 这种机制非常强大，相比较于 iOS 设备而言，Android 这个特性提供了非常便捷的用户体验。iOS 用户（包括我在内）会觉得频繁的返回主界面或者操作任务切换是非常低效的。</p>

<p>当然，这也并不意味着在应用之间分享数据这方面 Android 的技术就是更好的或者说其实现方式更高级。归根结底，这是个人喜好问题，就像有些 iOS 用户就不喜欢 Android 设备的<em>返回键</em>而 Android 用户却特别中意。理由是这些 Android 用户觉得返回键标准、高效且位置固定，总是在 <em>home</em> 键旁。</p>

<p>我记得我在西班牙生活的时候，曾经听过一个很棒的谚语： “Colors were created so we can all have different tastes”（“各花入各眼，存在即合理”）。</p>

<h2 id="">延伸阅读</h2>

<ul>
<li><a href="http://developer.android.com/guide/components/intents-filters.html">Intents and Filters</a></li>
<li><a href="http://developer.android.com/reference/android/content/Intent.html">Intents</a></li>
<li><a href="http://developer.android.com/guide/components/intents-common.html">Common Intents</a></li>
<li><a href="http://android-developers.blogspot.com.es/2009/11/integrating-application-with-intents.html">Integrating Application with Intents</a></li>
<li><a href="http://developer.android.com/training/sharing/index.html">Sharing Simple Data</a></li>
</ul>

<p>[^1]: Activities 是在你的应用中提供单个屏幕的用户界面的组件。</p>

<p>[^2]: Fragment 代表了一个 activity 中的行为或者一部分用户界面。</p>

<p>[^3]: 由字符串到 一组 Parcelable 类型的映射。</p>

<p>[^4]: Service 是这样一种应用组件：当用户与应用无交互时，它还可以执行长时间运行的操作，或者为其他应用提供某种功能。</p>

<p>[^5]: <a href="http://developer.android.com/reference/android/content/pm/PackageManager.html">PackageManager</a>: 是用来从当前安装在设备上的 package 中获取各类信息的类。</p>

<hr />

<p><a href="../issue-11.1.html">话题 #11 下的更多文章</a></p>

<p>原文 <a href="http://www.objc.io/issue-11/android-intents.html">Android Intents</a></p>
                    </div>
                    <h3>关于译者</h3>
                    <div class="at_author">
                        <div class="row">
                            <div class="medium-2 columns show-for-medium-up">
                                <div class="at_author_image">
                                    <img src="../content/images/2014/Mar/sunset.jpg" alt="sunset">
                                </div>
                            </div>
                            <div class="medium-10 columns">
                                <div class="at_author_name">
                                    <h3>sunset</h3>
                                </div>
                                <div class="at_author_bio">
                                    <p>Female, (Mobile Application) R&amp;D Manager</p>
                                    <p><a href="http://weibo.com/beatifulcodes">http://weibo.com/beatifulcodes</a>
                                </div>
                            </div>
                        </div>
                    </div>
                </article>
            </div>
            
        </div>
    </div>
</div>


<div id="at_footer">
	<div class="row">
		<div class="large-12 columns text-center">
			<div class="at_block">
				<div class="copyright">
					<span>&copy; 2015 <a href="../index.html">objc中国</a><br />本站由 <a href="http://im.onevcat.com">@onevcat</a> 创建，文章源自 <a href="http://objc.io">objc.io</a>，由 <a href="https://github.com/objccn">objc中国 项目组</a>整理维护</span>
				</div>
			</div>
		</div>
	</div>
</div>
        </div>
    </div>

    
    <script src="http://ajax.aspnetcdn.com/ajax/jQuery/jquery-2.1.0.min.js"></script>
    <script>window.jQuery || document.write('<script src="../assets/js/jquery-2.1.0.min.js"><\/script>')</script>

    <script>
        var ghostionConfig = {
            site_url:                       "objccn.io",
            google_fonts_family:            "Open+Sans:400,400italic,700,700italic",
            google_analytics_tracking_id:   "UA-49045539-1",
            disqus_shortname:               "objccn"
        };
    </script>
    <script src="../assets/js/ghostion.min.js"></script>
    
</body>
</html>